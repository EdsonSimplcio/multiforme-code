})();







// Script para remover invent√°rio do √¢ngulo 

(function () {
  // === REMOVER INVENT√ÅRIO VISUAL ===
  const barra = document.getElementById("barraInventario");
  if (barra) {
    barra.remove();
    console.log("üóëÔ∏è Barra de invent√°rio removida.");
  }

  // === REMOVER BOT√ÉO DE CRAFTING ===
  const botao = document.getElementById("botaoCrafitar");
  if (botao) {
    botao.remove();
    console.log("üóëÔ∏è Bot√£o de crafting removido.");
  }

  // === REMOVER ESTILO INVENT√ÅRIO ===
  const style = document.querySelector("style");
  if (style && style.textContent.includes(".slotItem")) {
    style.remove();
    console.log("üóëÔ∏è Estilo de invent√°rio removido.");
  }

  alert("‚úÖ Invent√°rio removido com sucesso!");
})();











// invent√°rio espinhos de peixe remove ouro

(function () {
  if (document.getElementById("barraInventario")) return;

  const inventario = [];
  let bracoAtivo = null;
  let tipoBraco = null;

  // === INVENT√ÅRIO VISUAL ===
  const barra = document.createElement("div");
  barra.id = "barraInventario";
  barra.style = `
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    background: rgba(0,0,0,0.5);
    padding: 6px 10px;
    border-radius: 8px;
    z-index: 1000;
  `;
  document.body.appendChild(barra);

  const style = document.createElement("style");
  style.textContent = `
    .slotItem {
      width: 40px;
      height: 40px;
      border: 2px solid #fff;
      box-sizing: border-box;
      cursor: pointer;
    }
    .slotItem.selected {
      border-color: yellow;
      box-shadow: 0 0 8px yellow;
    }
  `;
  document.head.appendChild(style);

  // === BOT√ÉO CRAFTING ===
  const botao = document.createElement("button");
  botao.id = "botaoCrafitar";
  botao.textContent = "üõ†Ô∏è Crafitar";
  botao.style = `
    position: absolute;
    bottom: 70px;
    right: 10px;
    padding: 10px 16px;
    font-size: 16px;
    background: #333;
    color: #fff;
    border: 2px solid #fff;
    border-radius: 6px;
    cursor: pointer;
    z-index: 1000;
  `;
  document.body.appendChild(botao);

  // === CRIA BRA√áO ===
  function criarBracoSolto(cor = "#ffffff", tipo = "branco") {
    if (bracoAtivo) {
      camera.remove(bracoAtivo);
      bracoAtivo = null;
    }

    let braco;

    if (tipo === "preto") {
      const grupo = new THREE.Group();
      const haste = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 2.5),
        new THREE.MeshStandardMaterial({ color: "#222222" })
      );
      haste.position.set(0, 0, -1.25);
      grupo.add(haste);

      const cabeca = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.1, 0.1),
        new THREE.MeshStandardMaterial({ color: "#444444" })
      );
      cabeca.position.set(0, 0.2, -2);
      grupo.add(cabeca);

      grupo.position.set(0.5, -0.5, -1.5);
      grupo.rotation.y = Math.PI / 8;
      braco = grupo;
    } else if (tipo === "cinza") {
      const grupo = new THREE.Group();
      const haste = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 2.5),
        new THREE.MeshStandardMaterial({ color: "#888888" })
      );
      haste.position.set(0, 0, -1.25);
      grupo.add(haste);

      for (let i = 0; i < 6; i++) {
        const espinho = new THREE.Mesh(
          new THREE.ConeGeometry(0.1, 0.3, 4),
          new THREE.MeshStandardMaterial({ color: "#aaaaaa" })
        );

//###############
        espinho.rotation.x = Math.PI;
        espinho.position.set(0, 0, -0.4 * i);
        grupo.add(espinho);
//###############

      }

      grupo.position.set(0.5, -0.5, -1.5);
      grupo.rotation.y = Math.PI / 8;
      braco = grupo;
    } else {
      const geometry = new THREE.BoxGeometry(0.3, 0.3, 3);
      const material = new THREE.MeshStandardMaterial({ color: cor });
      braco = new THREE.Mesh(geometry, material);
      braco.position.set(0.5, -0.5, -1.5);
      braco.rotation.y = Math.PI / 8;
    }

    camera.add(braco);
    scene.add(camera);
    bracoAtivo = braco;
    tipoBraco = tipo;
  }

  // === LOOP DE COLIS√ÉO ===
  setInterval(() => {
    if (!bracoAtivo) return;
    const bracoBox = new THREE.Box3().setFromObject(bracoAtivo);

    for (let i = cubes.length - 1; i >= 0; i--) {
      const cubo = cubes[i];
      const cuboBox = new THREE.Box3().setFromObject(cubo);
      const tipo = cubo.userData.tipo;

      if (bracoBox.intersectsBox(cuboBox)) {
        if (tipoBraco === "branco" && tipo === "especial") {
          cubo.parent?.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("800080");
          atualizarInventario();
        }

        if (tipoBraco === "roxo" && tipo === "preto") {
          cubo.parent?.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("555555");
          atualizarInventario();
        }

        if (tipoBraco === "preto" && tipo === "cinza") {
          cubo.parent?.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("888888");
          atualizarInventario();
        }

        if (tipoBraco === "cinza" && tipo === "amarelo") {
          cubo.parent?.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("ffff00");
          atualizarInventario();
        }
      }
    }
  }, 100);

  // === INVENT√ÅRIO ===
  function atualizarInventario() {
    const contagem = {};
    inventario.forEach(cor => {
      contagem[cor] = (contagem[cor] || 0) + 1;
    });

    barra.innerHTML = "";
    Object.entries(contagem).forEach(([cor, qtd]) => {
      const slot = document.createElement("div");
      slot.className = "slotItem";
      slot.style.background = "#" + cor;
      slot.title = `${cor} (${qtd})`;

      slot.addEventListener("click", () => {
        const index = inventario.findIndex(c => c === cor);
        if (index !== -1) {
          inventario.splice(index, 1);
          atualizarInventario();

          if (isSphere === true) {
            if (cor === "8b4513") criarBracoSolto("#ffffff", "branco");
            else if (cor === "800080") criarBracoSolto("#800080", "roxo");
            else if (cor === "555555") criarBracoSolto("#222222", "preto");
            else if (cor === "888888") criarBracoSolto("#888888", "cinza");
          }
        }
      });

      barra.appendChild(slot);
    });
  }

  // === CRAFTING ===
  function encontrarBlocoProximo() {
    const px = camera.position.x;
    const py = -world.position.y;
    const pz = camera.position.z;
    let maisProximo = null;
    let menorDist = Infinity;

    for (let i = 0; i < cubes.length; i++) {
      const mesh = cubes[i];
      const dx = px - (mesh.position.x + world.position.x);
      const dy = py - mesh.position.y;
      const dz = pz - (mesh.position.z + world.position.z);
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (dist < 1.5 && dist < menorDist) {
        menorDist = dist;
        maisProximo = mesh;
      }
    }

    return maisProximo;
  }

  function removerBlocosConectados(base) {
    const visitados = new Set();
    const fila = [base];
    const coresRemovidas = [];

    while (fila.length > 0) {
      const atual = fila.pop();
      if (!atual || visitados.has(atual.uuid)) continue;

      visitados.add(atual.uuid);
      const cor = atual.material.color.getHexString().toLowerCase();
    //  coresRem



coresRemovidas.push(cor);

      if (atual.parent) atual.parent.remove(atual);
      const index = cubes.findIndex(c => c.uuid === atual.uuid);
      if (index !== -1) cubes.splice(index, 1);

      const vizinhos = cubes.filter(c => {
        const dx = Math.abs(c.position.x - atual.position.x);
        const dy = Math.abs(c.position.y - atual.position.y);
        const dz = Math.abs(c.position.z - atual.position.z);
        return dx + dy + dz === 1;
      });

      fila.push(...vizinhos);
    }

    return coresRemovidas;
  }

  function crafitarCubo() {
    const alvo = encontrarBlocoProximo();
    if (alvo) {
      const cores = removerBlocosConectados(alvo);
      inventario.push(...cores);
      atualizarInventario();
      alert(`‚úÖ ${cores.length} blocos coletados!`);
    } else {
      alert("‚ùå Nenhum cubo pr√≥ximo para crafitar.");
    }
  }

  botao.addEventListener("click", crafitarCubo);
*/ /*
  // === √ÅRVORES ===
  for (let t = 0; t < 5; t++) {
    const x = t * 6;
    const y = 0;
    const z = 0;
    const altura = 4;

    for (let i = 0; i < altura; i++) {
      placeBlock(x, y + i, z, "wood");
    }

    const topo = y + altura;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = 0; dy <= 2; dy++) {
          const distancia = Math.abs(dx) + Math.abs(dz) + dy;
          if (distancia <= 3) {
            placeBlock(x + dx, topo + dy, z + dz, "grass");
          }
        }
      }
    }
  }*/
/*
  // === CUBOS ESPECIAIS ===
  function criarCuboEspecial(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#800080' }); // roxo
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "especial";
    world.add(cubo);
    cubes.push(cubo);
  }

  function criarCuboPreto(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#000000' }); // preto
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "preto";
    world.add(cubo);
    cubes.push(cubo);
  }

  function criarCuboCinza(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#555555' }); // cinza
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "cinza";
    world.add(cubo);
    cubes.push(cubo);
  }

  function criarCuboAmarelo(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#ffff00' }); // amarelo
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "amarelo";
    world.add(cubo);
    cubes.push(cubo);
  }

  // Cria cubos especiais para teste
  criarCuboEspecial(2, 1, 0); // roxo
  criarCuboPreto(4, 1, 0);    // preto
  criarCuboCinza(6, 1, 0);    // cinza
  criarCuboAmarelo(8, 1, 0);  // amarelo

  alert("‚úÖ Sistema completo: bra√ßo branco ‚Üí roxo ‚Üí preto (picareta) ‚Üí cinza (espinhos) ‚Üí amarelo!");
})();




(function () {
  if (document.getElementById("barraInventario")) return;

  const inventario = [];
  let bracoAtivo = null;
  let tipoBraco = null;

  // === INVENT√ÅRIO VISUAL ===
  const barra = document.createElement("div");
  barra.id = "barraInventario";
  barra.style.position = "absolute";
  barra.style.bottom = "10px";
  barra.style.left = "50%";
  barra.style.transform = "translateX(-50%)";
  barra.style.display = "flex";
  barra.style.gap = "6px";
  barra.style.background = "rgba(0,0,0,0.5)";
  barra.style.padding = "6px 10px";
  barra.style.borderRadius = "8px";
  barra.style.zIndex = "1000";
  document.body.appendChild(barra);

  const style = document.createElement("style");
  style.textContent = `
    .slotItem {
      width: 40px;
      height: 40px;
      border: 2px solid #fff;
      box-sizing: border-box;
      cursor: pointer;
    }
    .slotItem.selected {
      border-color: yellow;
      box-shadow: 0 0 8px yellow;
    }
  `;
  document.head.appendChild(style);

  // === BOT√ÉO CRAFTING ===
  const botao = document.createElement("button");
  botao.id = "botaoCrafitar";
  botao.textContent = "üõ†Ô∏è Crafitar";
  botao.style.position = "absolute";
  botao.style.bottom = "70px";
  botao.style.right = "10px";
  botao.style.padding = "10px 16px";
  botao.style.fontSize = "16px";
  botao.style.background = "#333";
  botao.style.color = "#fff";
  botao.style.border = "2px solid #fff";
  botao.style.borderRadius = "6px";
  botao.style.cursor = "pointer";
  botao.style.zIndex = "1000";
  document.body.appendChild(botao);

  // === CRIA BRA√áO ===
  function criarBracoSolto(cor = "#ffffff", tipo = "branco") {
    if (bracoAtivo) {
      camera.remove(bracoAtivo);
      bracoAtivo = null;
    }

    let braco;

    if (tipo === "preto") {
      const grupo = new THREE.Group();
      const haste = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 2.5),
        new THREE.MeshStandardMaterial({ color: "#222222" })
      );
      haste.position.set(0, 0, -1.25);
      grupo.add(haste);

      const cabeca = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.1, 0.1),
        new THREE.MeshStandardMaterial({ color: "#444444" })
      );
      cabeca.position.set(0, 0.2, -2);
      grupo.add(cabeca);

      grupo.position.set(0.5, -0.5, -1.5);
      grupo.rotation.y = Math.PI / 8;
      braco = grupo;
    } else if (tipo === "cinza") {
      const grupo = new THREE.Group();
      const haste = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 2.5),
        new THREE.MeshStandardMaterial({ color: "#888888" })
      );
      haste.position.set(0, 0, -1.25);
      grupo.add(haste);

      for (let i = 0; i < 6; i++) {
        const espinho = new THREE.Mesh(
          new THREE.ConeGeometry(0.1, 0.3, 4),
          new THREE.MeshStandardMaterial({ color: "#aaaaaa" })
        );
        espinho.rotation.x = Math.PI;
        espinho.position.set(0, 0.15, -0.4 * i);
        grupo.add(espinho);
      }

      grupo.position.set(0.5, -0.5, -1.5);
      grupo.rotation.y = Math.PI / 8;
      braco = grupo;
    } else {
      const geometry = new THREE.BoxGeometry(0.3, 0.3, 3);
      const material = new THREE.MeshStandardMaterial({ color: cor });
      braco = new THREE.Mesh(geometry, material);
      braco.position.set(0.5, -0.5, -1.5);
      braco.rotation.y = Math.PI / 8;
    }

    camera.add(braco);
    scene.add(camera);
    bracoAtivo = braco;
    tipoBraco = tipo;
  }

  // === LOOP DE COLIS√ÉO ===
  setInterval(() => {
    if (!bracoAtivo) return;
    const bracoBox = new THREE.Box3().setFromObject(bracoAtivo);

    for (let i = cubes.length - 1; i >= 0; i--) {
      const cubo = cubes[i];
      const cuboBox = new THREE.Box3().setFromObject(cubo);
      const tipo = cubo.userData.tipo;

      if (bracoBox.intersectsBox(cuboBox)) {
        if (tipoBraco === "branco" && tipo === "especial") {
          if (cubo.parent) cubo.parent.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("800080");
          atualizarInventario();
        }

        if (tipoBraco === "roxo" && tipo === "preto") {
          if (cubo.parent) cubo.parent.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("555555");
          atualizarInventario();
        }

        if (tipoBraco === "preto" && tipo === "cinza") {
          if (cubo.parent) cubo.parent.remove(cubo);
          cubes.splice(i, 1);
          inventario.push("888888");
          atualizarInventario();
        }
      }
    }
  }, 100);

  // === INVENT√ÅRIO ===
  function atualizarInventario() {
    const contagem = {};
    inventario.forEach(cor => {
      contagem[cor] = (contagem[cor] || 0) + 1;
    });

    barra.innerHTML = "";
    Object.entries(contagem).forEach(([cor, qtd]) => {
      const slot = document.createElement("div");
      slot.className = "slotItem";
      slot.style.background = "#" + cor;
      slot.title = `${cor} (${qtd})`;

      slot.addEventListener("click", () => {
        const index = inventario.findIndex(c => c === cor);
        if (index !== -1) {
          inventario.splice(index, 1);
          atualizarInventario();

          if (isSphere === true) {
            if (cor === "8b4513") criarBracoSolto("#ffffff", "branco");
            else if (cor === "800080") criarBracoSolto("#800080", "roxo");
            else if (cor === "555555") criarBracoSolto("#222222", "preto");
            else if (cor === "888888") criarBracoSolto("#888888", "cinza");
          }
        }
      });

      barra.appendChild(slot);
    });
  }

  // === CRAFTING ===
  function encontrarBlocoProximo() {
    const px = camera.position.x;
    const py = -world.position.y;
    const pz = camera.position.z;
    let maisProximo = null;
    let menorDist = Infinity;

    for (let i = 0; i < cubes.length; i++) {
      const mesh = cubes[i];
      const dx = px - (mesh.position.x + world.position.x);
      const dy = py - mesh.position.y;
      const dz = pz - (mesh.position.z + world.position.z);
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (dist < 1.5 && dist < menorDist) {
        menorDist = dist;
        maisProximo = mesh;
      }
    }

    return maisProximo;
  }

  function removerBlocosConectados(base) {
    const visitados = new Set();
    const fila = [base];
    const coresRemovidas = [];

    while (fila.length > 0) {
      const atual = fila.pop();
      if (!atual || visitados.has(atual.uuid)) continue;

      visitados.add(atual.uuid);
      const cor = atual.material.color.getHexString().toLowerCase();
   //   coresRemovidas.push





coresRemovidas.push(cor);

      if (atual.parent) atual.parent.remove(atual);
      const index = cubes.findIndex(c => c.uuid === atual.uuid);
      if (index !== -1) cubes.splice(index, 1);

      const vizinhos = cubes.filter(c => {
        const dx = Math.abs(c.position.x - atual.position.x);
        const dy = Math.abs(c.position.y - atual.position.y);
        const dz = Math.abs(c.position.z - atual.position.z);
        return dx + dy + dz === 1;
      });

      fila.push(...vizinhos);
    }

    return coresRemovidas;
  }

  function crafitarCubo() {
    const alvo = encontrarBlocoProximo();
    if (alvo) {
      const cores = removerBlocosConectados(alvo);
      inventario.push(...cores);
      atualizarInventario();
      alert(`‚úÖ ${cores.length} blocos coletados!`);
    } else {
      alert("‚ùå Nenhum cubo pr√≥ximo para crafitar.");
    }
  }

  botao.addEventListener("click", crafitarCubo);

  // === √ÅRVORES ===
  for (let t = 0; t < 5; t++) {
    const x = t * 6;
    const y = 0;
    const z = 0;
    const altura = 4;

    for (let i = 0; i < altura; i++) {
      placeBlock(x, y + i, z, "wood");
    }

    const topo = y + altura;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = 0; dy <= 2; dy++) {
          const distancia = Math.abs(dx) + Math.abs(dz) + dy;
          if (distancia <= 3) {
            placeBlock(x + dx, topo + dy, z + dz, "grass");
          }
        }
      }
    }
  }

  // === CUBOS ESPECIAIS ===
  function criarCuboEspecial(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#800080' }); // roxo
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "especial";
    world.add(cubo);
    cubes.push(cubo);
  }

  function criarCuboPreto(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#000000' }); // preto
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "preto";
    world.add(cubo);
    cubes.push(cubo);
  }

  function criarCuboCinza(x, y, z) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ color: '#555555' }); // cinza
    const cubo = new THREE.Mesh(geometry, material);
    cubo.position.set(x, y, z);
    cubo.userData.tipo = "cinza";
    world.add(cubo);
    cubes.push(cubo);
  }

  // Cria cubos especiais para teste
  criarCuboEspecial(2, 1, 0); // roxo
  criarCuboPreto(4, 1, 0);    // preto
  criarCuboCinza(6, 1, 0);    // cinza

  alert("‚úÖ Sistema completo: bra√ßo branco ‚Üí roxo ‚Üí preto (picareta) ‚Üí cinza (espinhos)!");
})();
*/







      

/*
üé§üé§üé§üéôÔ∏èüéôÔ∏èüéôÔ∏èüìªüìù‚úèÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏èüì¢üì¢üì¢üì¢


üé§üé§üé§üé§üé§üéôÔ∏èüéôÔ∏èüìªüéôÔ∏èüéôÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏è‚úèÔ∏èüì¢üì¢üì¢üì¢
*/
// Criar bot√£o "Chat"
const chatBtn = document.createElement("button");
chatBtn.innerText = "üí¨ Chat";
chatBtn.style.position = "fixed";
chatBtn.style.top = "60px";
chatBtn.style.right = "10px";
chatBtn.style.zIndex = "1000";
chatBtn.style.padding = "8px 12px";
chatBtn.style.background = "#0084ff";
chatBtn.style.color = "white";
chatBtn.style.border = "none";
chatBtn.style.borderRadius = "6px";
chatBtn.style.cursor = "pointer";

let chatWin; // vari√°vel para guardar a janela

chatBtn.onclick = () => {
  if (!chatWin) {
    chatWin = document.createElement("iframe");
    chatWin.src = "https://edsonsimplcio.github.io/Meu-jogo-multiplayer-/";
    chatWin.style.position = "fixed";
    chatWin.style.top = "10px";
    chatWin.style.left = "10px";
    chatWin.style.width = "300px";
    chatWin.style.height = "200px";
    chatWin.style.border = "2px solid #444";
    chatWin.style.borderRadius = "8px";
    chatWin.style.zIndex = "1001";
    chatWin.style.backgroundColor = "transparent";
    chatWin.style.opacity = "0.7"; // transl√∫cido

    document.body.appendChild(chatWin);

    // Bot√£o aumentar
    const biggerBtn = document.createElement("button");
    biggerBtn.innerText = "‚ûï";
    biggerBtn.style.position = "fixed";
    biggerBtn.style.top = "10px";
    biggerBtn.style.left = "320px";
    biggerBtn.style.zIndex = "1002";
    biggerBtn.onclick = () => {
      chatWin.style.width = (parseInt(chatWin.style.width) + 50) + "px";
      chatWin.style.height = (parseInt(chatWin.style.height) + 30) + "px";
    };
    document.body.appendChild(biggerBtn);

    // Bot√£o diminuir
    const smallerBtn = document.createElement("button");
    smallerBtn.innerText = "‚ûñ";
    smallerBtn.style.position = "fixed";
    smallerBtn.style.top = "40px";
    smallerBtn.style.left = "320px";
    smallerBtn.style.zIndex = "1002";
    smallerBtn.onclick = () => {
      chatWin.style.width = (parseInt(chatWin.style.width) - 50) + "px";
      chatWin.style.height = (parseInt(chatWin.style.height) - 30) + "px";
    };
    document.body.appendChild(smallerBtn);
  }
};

document.body.appendChild(chatBtn);







</textarea><br>
   
    <button id="runCode">‚ñ∂Ô∏è Executar C√≥digo</button>
    <button onclick="exportarMundo()">üíæ Salvar Mundo</button>
    <label for="carregarMundo" style="background:#333; color:white; padding:6px 12px; cursor:pointer;">üìÇ Carregar Mundo</label>


  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>


const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.background = new THREE.Color('#87CEEB');

    const luz = new THREE.DirectionalLight(0xffffff, 1);
    luz.position.set(10, 20, 10);
    scene.add(luz);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const world = new THREE.Group();
    scene.add(world);


// Criar um canvas para textura
const canvas = document.createElement('canvas');
canvas.width = 1024;
canvas.height = 1024;
const ctx = canvas.getContext('2d');

// Fundo verde (grama)
ctx.fillStyle = '#3CAC3C';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Fun√ß√£o para desenhar manchas arredondadas
function desenharMancha(x, y, raio, corCentro, corBorda) {
  const grad = ctx.createRadialGradient(x, y, raio * 0.2, x, y, raio);
  grad.addColorStop(0, corCentro);
  grad.addColorStop(1, corBorda);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, raio, 0, Math.PI * 2);
  ctx.fill();
}

// √Åreas de terra (marrom)
desenharMancha(300, 300, 180, '#7B4F2F', '#3CAC3C');
desenharMancha(700, 500, 220, '#6B3F2F', '#3CAC3C');

// √Åreas de areia (bege)
desenharMancha(600, 200, 150, '#D2B48C', '#3CAC3C');
desenharMancha(200, 700, 200, '#E0C68C', '#3CAC3C');

// Criar textura a partir do canvas
const texture = new THREE.CanvasTexture(canvas);

// Aplicar no plano
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(1800, 1800),
  new THREE.MeshStandardMaterial({ map: texture })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -3.5;
world.add(ground);



/*
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1800, 1800),
      new THREE.MeshStandardMaterial({ color: '#3CAC3C' })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -3.5;
    world.add(ground);
*/


    const cubes = [];
    const blocosCriados = [];

    function placeBlock(x, y, z, tipo = "stone") {
      const cores = {
        stone: "#888888",
        wood: "#a0522d",
        grass: "#00cc66",
        gold: "#ffd700",
        iron: "#d8d8d8",
        sand: "#f4e2b5"
      };
      const cor = cores[tipo] || "#ffffff";
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: cor });
      const block = new THREE.Mesh(geometry, material);
      block.position.set(x, y, z);
      world.add(block);
      cubes.push(block);
      blocosCriados.push({ x, y, z, tipo });
    }

    function exportarMundo() {
      const data = JSON.stringify(blocosCriados, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "meu_mundo.json";
      link.click();
    }

    document.getElementById("carregarMundo").addEventListener("change", function (e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const blocos = JSON.parse(event.target.result);
          blocos.forEach(b => placeBlock(b.x, b.y, b.z, b.tipo));
        } catch (err) {
          alert("Erro ao carregar o mundo: " + err.message);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("runCode").addEventListener("click", () => {
      const code = document.getElementById("codeInput").value;
      try {
        const func = new Function("placeBlock", code);
        func(placeBlock);
      } catch (e) {
        alert("Erro no c√≥digo: " + e.message);
      }
    });

    function criarNuvem(x, y, z) {
      const geometria = new THREE.BoxGeometry(2, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 'white' });
      const nuvem = new THREE.Mesh(geometria, material);
      nuvem.position.set(x, y, z);
      scene.add(nuvem);
    }

    criarNuvem(5, 10, -10);
    criarNuvem(-5, 12, -15);
    criarNuvem(0, 11, -8);

    const characterr = new THREE.Group();
    characterr.position.y = -6.4;

    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x5555ff }));
    body.position.y = 1.5;
    characterr.add(body);

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
    head.position.y = 2.5;
    characterr.add(head);

    const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
    armR.position.set(0.65, 1.5, 0);
    characterr.add(armR);

    const armL = armR.clone();
    armL.position.set(-0.65, 1.5, 0);
    characterr.add(armL);

    const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
    legR.position.set(0.3, 0, 0);
    characterr.add(legR);

    const legL = legR.clone();
    legL.position.set(-0.3, 0, 0);
    characterr.add(legL);

    scene.add(characterr);
    camera.position.set(0, 1.6, 0);


// Lista de blocos especiais com posi√ß√µes e tipos diferentes
const blocosEspeciais = [
  { x: 0, y: 0, z: 5, tipo: "gold" },
  { x: 2, y: 0, z: 5, tipo: "wood" },
  { x: -2, y: 0, z: 5, tipo: "stone" },
  { x: 0, y: 0, z: 8, tipo: "brick" },
  { x: 3, y: 0, z: 3, tipo: "obsidian" }
];

// Cria todos os blocos especiais com suas cores/tipos
for (const bloco of blocosEspeciais) {
  placeBlock(bloco.x, bloco.y, bloco.z, bloco.tipo);
}


let cooldown = false;

function empurrarEParar() {
  if (cooldown) return;
  cooldown = true;

  const impulso = 1.5;
  const direcao = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
  world.position.add(direcao.multiplyScalar(impulso));

  const direcoesOriginais = { ...direcoesAtivas };
  direcoesAtivas.forward = false;
  direcoesAtivas.backward = false;
  direcoesAtivas.left = false;
  direcoesAtivas.right = false;

  setTimeout(() => {
    Object.assign(direcoesAtivas, direcoesOriginais);
    cooldown = false;
  }, 10);
}

// Verifica colis√£o com todos os blocos especiais
setInterval(() => {
  const px = camera.position.x;
  const py = -world.position.y;
  const pz = camera.position.z;

  for (const bloco of blocosEspeciais) {
    const bx = bloco.x + world.position.x;
    const by = bloco.y;
    const bz = bloco.z + world.position.z;

    const dx = Math.abs(px - bx);
    const dy = Math.abs(py - (by + 1));
    const dz = Math.abs(pz - bz);

    if (dx < 0.5 && dy < 0.6 && dz < 0.5) {
      empurrarEParar();
      break;
    }
  }
}, 10);


const direcoesAtivas = { forward: false, backward: false, left: false, right: false };
    let rotating = false, velocityY = 0, isJumping = false;
    const gravity = 0.01, jumpStrength = -0.25;
    let isSphere = false, armMesh = null, armAngle = 0;
    const bullets = [], bulletSpeed = 0.5;
    let isLooking = false, lastTouchX = 0, lastTouchY = 0;
    let yaw = 0, pitch = 0, idleTime = 0;

    function startMove(dir) { direcoesAtivas[dir] = true; }
    function stopMove(dir) { direcoesAtivas[dir] = false; }

    function transformToArm() {
      if (!isSphere) {
        characterr.visible = false;
        const geometry = new THREE.BoxGeometry(0.3, 0.3, 3);
        const material = new THREE.MeshStandardMaterial({ color: '#ffffff' });
        armMesh = new THREE.Mesh(geometry, material);
        scene.add(armMesh);
        isSphere = true;
      } else {
        if (armMesh) {
          scene.remove(armMesh);
          armMesh = null;
        }
        characterr.visible = true;
        isSphere = false;
      }
    }

    function shootBullet() {
      const origin = camera.position.clone();
      const direction = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const geometry = new THREE.SphereGeometry(0.1, 8, 8);
      const material = new THREE.MeshStandardMaterial({ color: '#ffff00' });
      const bullet = new THREE.Mesh(geometry, material);
      bullet.position.copy(origin);
      bullets.push({ mesh: bullet, direction });
      scene.add(bullet);
    }

    document.getElementById('jump').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!isJumping) {
        velocityY = jumpStrength;
        isJumping = true;
      }
    });

    document.getElementById('left').addEventListener('touchstart', () => startMove('left'));
    document.getElementById('right').addEventListener('touchstart', () => startMove('right'));
    document.getElementById('forward').addEventListener('touchstart', () => startMove('forward'));
    document.getElementById('backward').addEventListener('touchstart', () => startMove('backward'));
    document.getElementById('left').addEventListener('touchend', () => stopMove('left'));
    document.getElementById('right').addEventListener('touchend', () => stopMove('right'));
    document.getElementById('forward').addEventListener('touchend', () => stopMove('forward'));
    document.getElementById('backward').addEventListener('touchend', () => stopMove('backward'));
    document.getElementById('morph').addEventListener('click', transformToArm);

    document.addEventListener('keydown', (e) => {
      switch (e.key.toLowerCase()) {
        case 'w': startMove('forward'); break;
        case 's': startMove('backward'); break;
        case 'a': startMove('left'); break;
        case 'd': startMove('right'); break;
        case ' ': if (!isJumping) { velocityY = jumpStrength; isJumping = true; } break;
        case 'r': rotating = true; break;
        case 'm': transformToArm(); break;
        case 'f': shootBullet(); break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.key.toLowerCase()) {
        case 'w': stopMove('forward'); break;
        case 's': stopMove('backward'); break;
        case 'a': stopMove('left'); break;
        case 'd': stopMove('right'); break;
        case 'r': rotating = false; break;
      }
    });

    renderer.domElement.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        isLooking = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
      }
    });

    renderer.domElement.addEventListener('touchmove', e => {
      if (isLooking && e.touches.length === 1) {
        const touch = e.touches[0];
        const deltaX = touch.clientX - lastTouchX;
        const deltaY = touch.clientY - lastTouchY;
        yaw -= deltaX * 0.005;
        pitch -= deltaY * 0.005;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
      }
    });

    renderer.domElement.addEventListener('touchend', () => {
      isLooking = false;
    });

    const toggleEditorBtn = document.createElement("button");
    toggleEditorBtn.textContent = "Ocultar Editor";
    toggleEditorBtn.style.position = "absolute";
    toggleEditorBtn.style.top = "10px";
    toggleEditorBtn.style.right = "10px";
    toggleEditorBtn.style.zIndex = "1000";
    toggleEditorBtn.style.padding = "8px 12px";
    toggleEditorBtn.style.background = "#333";
    toggleEditorBtn.style.color = "#fff";
    toggleEditorBtn.style.border = "none";
    toggleEditorBtn.style.borderRadius = "4px";
    toggleEditorBtn.style.cursor = "pointer";
    document.body.appendChild(toggleEditorBtn);

    toggleEditorBtn.addEventListener("click", () => {
      const panel = document.getElementById("codePanel");
      if (!panel) return;
      if (panel.style.display === "none") {
        panel.style.display = "block";
        toggleEditorBtn.textContent = "Ocultar Editor";
      } else {
        panel.style.display = "none";
        toggleEditorBtn.textContent = "Mostrar Editor";
      }
    });






// Lista de vaquinhas
const vaquinhas = [];

// Cria uma vaquinha com corpo, cabe√ßa e patas
function criarVacaAleatoria() {
  const vaca = new THREE.Group();

  // Corpo
  const corpoGeo = new THREE.BoxGeometry(1, 1, 1.5);
  const corpoMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const corpo = new THREE.Mesh(corpoGeo, corpoMat);
  corpo.position.set(0, 0.5, 0);
  vaca.add(corpo);

  // Cabe√ßa
  const cabecaGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
  const cabecaMat = new THREE.MeshStandardMaterial({ color: 0xA0522D });
  const cabeca = new THREE.Mesh(cabecaGeo, cabecaMat);
  cabeca.position.set(0, 0.6, 1.1);
  vaca.add(cabeca);

  // Pernas
  const pernaGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
  const pernaMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const pernas = [];

  const posicoes = [
    [-0.35, -0.3,  0.5],
    [ 0.35, -0.3,  0.5],
    [-0.35, -0.3, -0.5],
    [ 0.35, -0.3, -0.5]
  ];

  posicoes.forEach(pos => {
    const perna = new THREE.Mesh(pernaGeo, pernaMat);
    perna.position.set(...pos);
    vaca.add(perna);
    pernas.push(perna);
  });

  // Dados da vaquinha
  vaca.userData = {
    pernas,
    passo: 0,
    sentido: 1,
    destino: gerarDestinoAleatorio(),
    esperando: false,
    esperaTimer: 0
  };

  vaca.position.set(-200, 0, 100);
  world.add(vaca); // ‚úÖ agora usando world.add
  vaquinhas.push(vaca);
}

// Gera um destino aleat√≥rio no plano XZ
function gerarDestinoAleatorio() {
  const x = Math.random() * 20 - 10;
  const z = Math.random() * 20 - 10;
  return new THREE.Vector3(x, 0, z);
}






//**** scripts do editor do jogo****\\ 

// imagem paisagem fundo local

const texturaPaisagem = new THREE.TextureLoader().load('https://raw.githubusercontent.com/EdsonSimplcio/EdsonMemorieCard/refs/heads/main/minescriptpaisagem2.png  '); // ou 'imagens/paisagem.jpg' se estiver em subpasta

const raio = 800;
const altura = 850;
const segmentos = 64;

const geometriaCilindro = new THREE.CylinderGeometry(raio, raio, altura, segmentos, 1, true);
const materialCilindro = new THREE.MeshBasicMaterial({
  map: texturaPaisagem,
  side: THREE.BackSide
});

const cilindroPaisagem = new THREE.Mesh(geometriaCilindro, materialCilindro);
cilindroPaisagem.position.y = altura / 2 - 50;
scene.add(cilindroPaisagem);





// === Limite de Per√≠metro com Teletransporte ===
const limitePerimetro = 250; // Metade de 500x500
const pontoRetorno = new THREE.Vector3(0, 1.6, 0); // Posi√ß√£o segura para retornar

function verificarLimiteETeleportar() {
  const px = camera.position.x - world.position.x;
  const pz = camera.position.z - world.position.z;

  const foraDosLimites =
    px > limitePerimetro || px < -limitePerimetro ||
    pz > limitePerimetro || pz < -limitePerimetro;

  if (foraDosLimites) {
    world.position.set(0, 0, 0); // Reseta o mundo
    camera.position.set(pontoRetorno.x, pontoRetorno.y, pontoRetorno.z); // Reposiciona a c√¢mera
    console.log("üöß Voc√™ saiu da √°rea permitida. Teletransportado de volta!");
  }
}

// === Adiciona ao loop do editor ===
if (typeof atualizacoesEditor === 'undefined') {
  var atualizacoesEditor = [];
}
atualizacoesEditor.push(() => {
  verificarLimiteETeleportar();
});





/*

// criar √°rvores posicionada

// Lista de √°rvores para controle de visibilidade
const arvores = [];

// Cria √°rvore estilo Minecraft com blocos
function criarArvoreMinecraft(x, z, altura = 4) {
  const y = 0;
  const blocos = [];

  // Tronco
  for (let i = 0; i < altura; i++) {
    const bloco = placeBlock(x, y + i, z, "wood");
    blocos.push(bloco);
  }

  // Copa reduzida
  const topo = y + altura;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dz = -1; dz <= 1; dz++) {
      for (let dy = 0; dy <= 1; dy++) {
        const distancia = Math.abs(dx) + Math.abs(dz) + dy;
        if (distancia <= 2) {
          const bloco = placeBlock(x + dx, topo + dy, z + dz, "grass");
          blocos.push(bloco);
        }
      }
    }
  }

  // Armazena refer√™ncia da √°rvore como um grupo de blocos
  arvores.push({ x, z, blocos });
}

// Gera √°rvores espalhadas e distantes umas das outras
function gerarArvoresEspalhadas(qtd = 30, area = 800, minDist = 20) {
  const geradas = [];

  while (geradas.length < qtd) {
    const x = Math.floor(Math.random() * area) - area / 2;
    const z = Math.floor(Math.random() * area) - area / 2;

    // Verifica dist√¢ncia m√≠nima entre √°rvores
    const longe = geradas.every(pos => {
      const dx = pos.x - x;
      const dz = pos.z - z;
      return Math.sqrt(dx * dx + dz * dz) >= minDist;
    });

    if (longe) {
      criarArvoreMinecraft(x, z);
      geradas.push({ x, z });
    }
  }
}

// Atualiza visibilidade das √°rvores com base no campo de vis√£o
function atualizarVisibilidadeArvores(anguloVisao = Math.PI / 2) {
  const posCamera = camera.position.clone();
  const dirCamera = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();

  arvores.forEach(arvore => {
    const dirParaArvore = new THREE.Vector3(arvore.x, 0, arvore.z).sub(posCamera).setY(0).normalize();
    const angulo = dirCamera.angleTo(dirParaArvore);
    const visivel = angulo <= anguloVisao / 2;

    arvore.blocos.forEach(bloco => {
      if (bloco && bloco.mesh) bloco.mesh.visible = visivel;
    });
  });
}

// Gera as √°rvores uma vez
gerarArvoresEspalhadas(60, 600, 40);

// No loop de anima√ß√£o do jogo, adicione:
function animate() {
  requestAnimationFrame(animate);

  // ... outros c√≥digos do jogo ...

  atualizarVisibilidadeArvores(Math.PI / 2); // 90¬∞ de vis√£o

  renderer.render(scene, camera);
}



*/









// ==== CRIA√á√ÉO DO INIMIGO QUADR√öPEDE ave vaca ====

//let enemy = null;

function createEnemy() {
  const enemy = new THREE.Group();

  // Corpo
  const bodyGeo = new THREE.BoxGeometry(0, 0, 0); // (1.3, 0.3, 1);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  enemy.add(body);

  // Pernas
  const legGeo = new THREE.BoxGeometry(0, 0, 0); //( 0.2, 0.5, 0.2);
  const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

  const legs = [];

  const positions = [
   // [-0.4, -0.75,  0.4], // frente esquerda
    [ 0.4, -0.75,  0.4], // frente direita
  //  [-0.4, -0.75, -0.4], // tr√°s esquerda
    [ 0.4, -0.75, -0.4]  // tr√°s direita
  ];

  positions.forEach(pos => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(...pos);
    legs.push(leg);
    enemy.add(leg);
  });

  enemy.userData.legs = legs;
  enemy.position.set(20, 20, 0);
  world.add(enemy);
  return enemy;
}

// ==== INICIALIZA√á√ÉO COM ATRASO ====

setTimeout(() => {
  enemy = createEnemy();
}, 100000000000000000000000000); // aparece ap√≥s 5 segundos

// ==== LOOP DE ANIMA√á√ÉO ====









    function animate() {
      requestAnimationFrame(animate);
      const step = 0.1;
      idleTime += 0.03;









// Anima√ß√£o das vaquinhas
function animarVaquinhas() {
  vaquinhas.forEach(vaca => {
    const data = vaca.userData;
    const destino = data.destino;

    if (data.esperando) {
      data.esperaTimer -= 1;
      if (data.esperaTimer <= 0) {
        data.esperando = false;
        data.destino = gerarDestinoAleatorio();
      }
      return;
    }

    const pos = vaca.position;
    const dir = new THREE.Vector3().subVectors(destino, pos);
    const dist = dir.length();

    if (dist < 0.1) {
      data.esperando = true;
      data.esperaTimer = 100 + Math.floor(Math.random() * 100);
      return;
    }

    dir.normalize();
    vaca.position.addScaledVector(dir, 0.03);

    // Anima√ß√£o das patas
    data.passo += data.sentido * 0.1;
    if (data.passo > 0.4 || data.passo < -0.4) data.sentido *= -1;

    data.pernas[0].rotation.x = data.passo;
    data.pernas[1].rotation.x = -data.passo;
    data.pernas[2].rotation.x = -data.passo;
    data.pernas[3].rotation.x = data.passo;
  });
}




  
  animarVaquinhas();
  








// anima√ß√£o vaca

  if (enemy) {
    // Movimento lateral
    enemy.position.x += 0.01;

    // Anima√ß√£o das pernas
    enemy.userData.legs.forEach((leg, i) => {
      leg.rotation.x = Math.sin(Date.now() * 0.005 + i) * 0.5;
    });
  }

  



      // anima√ß√£o do personagem
      const andando = Object.values(direcoesAtivas).some(v => v);
      if (andando) {
        const runSpeed = idleTime * 2.5;
        body.position.y = 1.5 + Math.sin(runSpeed) * 0.08;
        head.rotation.y = Math.sin(runSpeed * 0.5) * 0.1;
        armL.rotation.z = Math.sin(runSpeed * 2) * 0.4;
        armR.rotation.z = -Math.sin(runSpeed * 2) * 0.4;
        legL.rotation.x = Math.sin(runSpeed * 2) * 0.4;
        legR.rotation.x = -Math.sin(runSpeed * 2) * 0.4;
      } else {
        body.position.y = 1.5 + Math.sin(idleTime) * 0.05;
        head.rotation.y = Math.sin(idleTime * 0.5) * 0.1;
        armL.rotation.z = Math.sin(idleTime * 1.5) * 0.1;
        armR.rotation.z = -Math.sin(idleTime * 1.5) * 0.1;
        legL.rotation.x = Math.sin(idleTime * 0.8) * 0.02;
        legR.rotation.x = -Math.sin(idleTime * 0.8) * 0.02;
      }

      const direction = new THREE.Vector3(
        Math.sin(yaw) * Math.cos(pitch),
        Math.sin(pitch),
        Math.cos(yaw) * Math.cos(pitch)
      );
      camera.lookAt(camera.position.clone().add(direction));

      const moveVector = new THREE.Vector3();
      if (direcoesAtivas.backward) moveVector.z -= 1;
      if (direcoesAtivas.forward) moveVector.z += 1;
      if (direcoesAtivas.right) moveVector.x -= 1;
      if (direcoesAtivas.left) moveVector.x += 1;

      if (moveVector.length() > 0) {
        moveVector.normalize();
        moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        world.position.sub(moveVector.multiplyScalar(step));
      }

      if (rotating) world.rotation.y += 0.02;

      if (isJumping) {
        velocityY += gravity;
        world.position.y += velocityY;

        let landed = false;
        cubes.forEach(cube => {
          const dx = Math.abs(camera.position.x - cube.position.x - world.position.x);
          const dz = Math.abs(camera.position.z - cube.position.z - world.position.z);
          const dy = -world.position.y - cube.position.y;
          if (dx < 1 && dz < 1 && dy > 0 && dy < 1) {
           // world.position.y = -cube.position







world.position.y = -cube.position.y - 1;
            velocityY = 0;
            isJumping = false;
            landed = true;
          }
        });

        if (!landed && world.position.y >= -1.4) {
          world.position.y = -1.4;
          velocityY = 0;
          isJumping = false;
        }
      }

      // ‚úÖ CORRE√á√ÉO: queda autom√°tica ao sair de blocos
      if (!isJumping) {
        let onCube = false;
        cubes.forEach(cube => {
          const dx = Math.abs(camera.position.x - cube.position.x - world.position.x);
          const dz = Math.abs(camera.position.z - cube.position.z - world.position.z);
          const dy = -world.position.y - cube.position.y;
          if (dx < 1 && dz < 1 && Math.abs(dy - 1) < 0.1) {
            onCube = true;
          }
        });
        if (!onCube && world.position.y < -1.4) {
          isJumping = true;
          velocityY = 0;
        }
      }



      // Atualiza posi√ß√£o do bra√ßo ou personagem
// bra√ßo segue a c√¢mera 
if (isSphere && armMesh) {
  const offset = new THREE.Vector3(0.7, -0.5, -1.3);
  const armPosition = offset.clone().applyQuaternion(camera.quaternion);
  armMesh.position.copy(camera.position.clone().add(armPosition));

  // Faz o bra√ßo herdar a rota√ß√£o da c√¢mera
  armMesh.quaternion.copy(camera.quaternion);


//bra√ßo fixo 
   /*   if (isSphere && armMesh) {
        const offset = new THREE.Vector3(-0.7, -0.5, 0.3);
        const armPosition = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        armMesh.position.copy(camera.position.clone().add(armPosition));
        armMesh.rotation.set(0, yaw, 3);*/
      } else {
        const offset = new THREE.Vector3(-0.4, -1.9, 5);
        const rotatedOffset = offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        characterr.position.copy(camera.position.clone().add(rotatedOffset));
        characterr.rotation.y = yaw;
      }

      // Atualiza proj√©teis
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.direction, bulletSpeed);
        if (b.mesh.position.distanceTo(camera.position) > 100) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
